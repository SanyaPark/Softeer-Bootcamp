# 🌅 하루 감상

!! 고친 것 !!
코드리뷰를 하며 강조하신 말씀은 처음 온 사람이 처음 코드를 봤을 때 
자연스럽게 이렇게 행동할거라 생각하는 코드를 짜야 한다는 것이다.
그 사람은 Extract 끝난 파일은 원본이 있을것이라 생각하기 때문에 
뭐 반올림 같은 작업도 하지 말고 순수하게 원본만 손대자.
같은 맥락에서, 단위 변환이 끝나기 전에 미리 컬럼 이름을 'bilion'으로 설정하지 말자.
내가 나중에 봐도 흐름 추적 시 헷갈릴 수 있겠다는 생각이 들었다.

### 오늘의 주의깊게 새길 말 :
> #### 문제 정의는 **'누구의' '어떤'** 문제

<br>

## 📚 배운 것
### 이 코드의 문제점은?
```python
while not tasks_that_are_done.empty():
    print(tasks_that_are_done.get())
return True
```
- while 조건문 판별 시점과 get() 시점이 미세하게 달라서 
- 멀티스레드/멀티프로세스 환경에서는 이 짧은 틈에 **concurrency 문제**가 발생할 수 있다.
- 요점은 이 **로직이 Atomic 하지 않아**서 race condition에서 의도치 않은 에러가 발생할 수 있다는 것!

<br> s

>오늘도 깃 올리려는데 http400에러가 나왔다. 
분명 해결했었는데 하... 
> ### git config http.postbuffer 524288000	
>앞으론 잊지 말자

<br>


### Docker Desktop의 유용한 기능
도커 컨테이너 내부를 Interactive 하게 보려면 도커 데스크탑 GUI에서 컨테이너를 실행 후 exec 탭에서 직접 터미널에 쳐 보면서 동작을 확인할 수 있다.
CMD, 엔트리포인트에서나 터미널 작업을 미리 해 볼수 있다는 장점!

<br>

### User-data / Container

* 무엇을 어디에 둬야 할까?
  * 무엇이 업데이트되어야 하고 무엇이 고정되어야 하는가
    * 전자는 user-data, 후자는 도커이미지

* 자주 업데이트되는 파일은?
  * 도커 이미지에 종속되는건 싫다 (수정 안할거임!) -> EC2에서 유저데이터 통해 git-clone하는게 맞을 듯
  * 아니면, 도커이미지를 버전 관리할거고 고정된 이름으로 ECR에 올려서 관리할거야.
<br><br>

### 도커파일 자체는 주피터 처럼 한줄 한줄 할 수는 없나?
--> **멀티 스테이지 빌드**를 사용하면 될 것 같다.

Dockerfile이 **멀티스테이지 빌드**를 포함하고 있다면, 
--target 옵션을 사용하여 **특정 빌드 단계까지 실행**하고 결과를 테스트할 수 있습니다.

``` Dockerfile
FROM ubuntu AS base
RUN apt-get update && apt-get install -y python3

FROM base AS build
RUN pip install flask
```

특정 스테이지만 빌드:
```docker build **--target base** -t base-stage-test .```
<br><br>

### 도커를 실행하는 세 가지 모드
1. **Interactive** **mode**
Docker를 사용하면 대화형 모드에서 컨테이너를 실행할 수 있습니다. 
이는 컨테이너가 실행 중인 동안 컨테이너 내에서 명령을 실행할 수 있음을 의미합니다. 
컨테이너를 대화식으로 사용하면 실행 중인 컨테이너 내부의 명령 프롬프트에 액세스할 수 있습니다.

2. **Attached mode**
Attached mode에서 Docker는 컨테이너에서 프로세스를 시작하고 콘솔을 프로세스의 표준 입력, 표준 출력 및 표준 오류에 연결할 수 있습니다.

3. **Detached mode**
컨테이너가 입력 또는 출력 스트림에 연결되지 않고 백그라운드에서 실행됨을 의미합니다.

**모드 간 비교**
| 특징	| Interactive Mode	| Attached Mode	| Detached Mode |
|---|---|---|---|
|터미널 연결	| 사용자와 컨테이너 **터미널이 연결됨**	|컨테이너 **출력이 터미널에 출력됨**	| 터미널과 **분리되어 백그라운드에서** 실행 |
|작업 성격	|**실시간** 작업, 디버깅	| **짧은 실행** 작업	| **지속적인** 서비스 실행 |
|터미널 반환	| 터미널이 반환되지 않음	| 터미널이 반환되지 않음	| 터미널이 **즉시 반환됨** |
|컨테이너 종료	| 터미널 닫히면 종료 |	터미널 닫히면 종료	| 터미널 **닫혀도 계속 실행** |
|주 사용 환경	| 테스트, 디버깅	| 간단한 명령 실행	| 서버, 프로덕션, 장기 실행 작업 |

---

### 💾 Keep
* 이제는 멀티프로세스 환경에서 돌아가는걸 상정하고 로직을 점검해야 한다.
Atomic하지 않은 자원 체크, 분배 등은 대규모 데이터 환경에서 치명적인 버그를 일으킬 수 있다.
<br>

* 도커 이미지 빌드 시 멀티스테이지 빌드를 적극 활용해야겠다.
아키텍쳐 잘못보고 거의 한 시간 날려먹었던 만큼 '어디까지 되는지 검증'을 습관화 해야겠다.
<br>

* 한 파일에다 ETL을 다 적고 있으니 분리가 안 되고 생각도 그렇게 안된다
<br>

* .map이 걸려있으면 보통 대체할 수 있는 판다스 메서드가 따로 있다.
.apply가 문제가 아니라 **.apply로 하나씩 꺼내오는**게 문제다
    보통 저게 문제되는 시점에는 저걸 대체할 수 있는 수단이 판다스에 있다.
<br>

* 왜 millions 데이터를 USD_bilion 이름의 컬럼에 넣는지...
  * 그래, 나다 ㅜㅜ

* 간결하게 읽히게 하기
   * 양파까듯이 타고 타고 타고 들어가게 하면 보는 사람도 힘들다

   * try : 여기는 뭔가 문제가 생길 수 있다 --> 근데 왜 여기를 길~~게 쓰냐고
